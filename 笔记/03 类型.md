## 具体类型

- 数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 `&str`
- 布尔类型： `true`和`false`
- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节
- 单元类型: 即 `()` ，其唯一的值也是 `()`

大多情况下编译器能够自动推导，如果无法确定时才一定要显式标注出来

## 整型

Rust 默认使用 `i32`

`isize` 和 `usize`（大小视架构而定） 的主要应用场景是用作集合的索引

Rust 不会检测溢出

## 浮点型

浮点型陷阱：

- 因为浮点数的机器码格式问题，**一些**十进制数不能精确表示，只能近似表示
	- 因此 0.1 + 0.2 != 0.3 而是 0.30000000000000004
		- 0.1+0.1 = 0.2 是正确的
	- 总之少用浮点数相等判断，可以用 (0.1_f 64 + 0.2 - 0.3). Abs () < 0.00001 来代替相等
	- 而且不能把浮点数作为 HashMap 的键值

- 规定数学上不能表示的数用 `NaN` 表示
	- 任何和 `NaN` 运算后都返回 `NaN`
	- 用 `is_nan` 判断

## 运算

只有类型相同的才能运算！也就是说 1+ 0.2 是不允许的

Rust 不会隐式地进行转换类型，必须使用 as 来显式转换！

同理，不同类型也不能比较

建议使用 as 将更小的类型转换为范围更大的类型，再进行运算、比较

## 序列

类似于 python 中的 range，但更方便

范围也是左开右闭：`[1, 6)`

```rust
for i in 1..6 {
	println!("{}", i);
}
```

## 字符

Rust 字符是 Unicode 字符，也就是一个中文、一个 emoji、一个英文字母等等都是一个字符，占 4 字节

注意字符只能用单引号，字符串只能用双引号

```rust
let x = '你';
println!("字符'中'占用了{}字节的内存大小",std::mem::size_of_val(&x));
```

> C 中 char 类型只占 1 字节

## 单元类型

单元类型就是 `()`，比如 `main()`， `println!()` 函数返回的值就是单元类型。

可以看成是一个没有实际意义的占位符。

`()` 一个常见的使用是：作为 map 键值对中的值，表示我们只关心键不关心值

注意返回单元类型的函数并不是没有返回值的函数，真正无返回值的函数在 rust 中称为发散函数。

因此，函数定义时不写返回值，编译器会自动推断为返回单元类型。

## 语句和表达式

Rust 中需要区分语句和表达式：

- 语句
	- 不会返回值（其实是返回 `()`）
	- 可以加 `;` 结尾，为了代码可读性一般都会加
- 表达式
	- 在运算结束后会返回一个值
	- 不能加 `;`，加了就变成语句
	- 如果表达式不返回任何值，那么返回的就是 `()`

比如：

- 函数的函数体中默认返回最后一个表达式的值，当然也可以显示的使用 `return`
- 语句不能作为赋值的值，`let a = (let b = 1)` 是错误的，但将来 let 可能会成为表达式

```rust
// 可以使用语句块来赋值
let y = {
	let x = 3;
	x + 1
	// 语句块返回表达式的值
};


// if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
// 类似三元运算符，在Rust里我们可以这样写
let y = if x % 2 == 1 {
	"odd"
} else {
	"even"
};
// 或者写成一行
let z = if x % 2 == 1 { "odd" } else { "even" };
```
