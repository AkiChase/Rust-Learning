##  cargo 指令

- 使用 `cargo new` 创建项目。
	- 使用 `--no-git` 选项，不创建 git 仓库
- 使用 `cargo build` 构建项目。
- 使用 `cargo run` 一步构建并运行项目。
- 使用 `cargo check` 在不生成二进制文件的情况下构建项目来检查错误
- 使用 `cargo build --release` 来优化编译项目
	- 会在 `target/release` 下生成优化编译后的可执行文件

## 变量

```rust
// 使用let来声明变量，进行绑定，默认情况下变量是不可变的
// 此处没有指定a的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数
// 语句的末尾必须以分号结尾
let a = 10;

// 主动指定b的类型为i32
let b: i32 = 20;

// 另一种声明方式
// 这里有两点值得注意：
// 1. 可以在数值中带上类型:30i32表示数值是30，类型是i32
// 2. c是可变的，mut是mutable的缩写
let mut c = 30i32;
// 还能在数值和类型中间添加一个下划线，让可读性更好
let d = 30_i32;

// 真正的常量
// u32无符号32位，100_100中的下划线仅仅是为了可读性
const MAX_POINT: u32 = 100_000;
```

Rust 会警告未使用的变量，所以在开发初期可以为其命名前加上下划线，展示忽略此变量 `let _a = 6;`

### 变量遮蔽

涉及作用域问题。

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;
    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        // 此时输出x * 2后的新x值12
        println!("The value of x in the inner scope is: {}", x);
    }
	// 此时还是输出之前的x+1后的新x的值6
    println!("The value of x is: {}", x);
}
```

这样直接使用 let 是新生成一个变量，和 `mut` 变量不一样，会新分配内存空间，只是变量名的小把戏。

用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。

## 命名规范

- 普通变量函数等用全小写+下划线（蛇形命名法）
- 结构体、枚举等用大驼峰
- 常量全大写+下划线
